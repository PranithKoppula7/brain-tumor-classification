# -*- coding: utf-8 -*-
"""Asymmetric Loss.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17o-Nkx3F66I6Vt29nnsOCanJdG1aaJ_l
"""

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import cv2
import os
from tqdm import tqdm
from tensorflow.keras.applications import EfficientNetB0
from keras import backend as K

labels = ['glioma_tumor', 'meningioma_tumor', 'no_tumor', 'pituitary_tumor']
X_train = []
y_train = []
image_size = 150
for i in labels:
    folderPath = os.path.join('/content/data','Training',i)
    for j in tqdm(os.listdir(folderPath)):
        img = cv2.imread(os.path.join(folderPath,j))
        img = cv2.resize(img,(image_size, image_size))
        X_train.append(img)
        y_train.append(i)
        
X_train = np.array(X_train)
y_train = np.array(y_train)

X_train.shape

plt.imshow(X_train[1].astype("uint8"))
plt.title(y_train[1])

class AssymetricLossNeuralNetwork():
    """
    This class abstract as simple nueral network with an assymetric loss. The parameter k is the multiplier for a class that needs to be prioritized.
    """
    def __init__(
            self,
            k: tuple,
            image_size: tuple,
            batch_size: int,
            ) -> None:
        self.k = k
        self.batch_size = batch_size
        self.image_size = image_size
        self.epsilon = 1e7
        self.X_train, self.y_train = self.load_training_data()

    def load_training_data(self):
        labels = ['glioma_tumor', 'meningioma_tumor', 'no_tumor', 'pituitary_tumor']
        X_train = []
        y_train = []
        for i in labels:
            folderPath = os.path.join('/content/data','Training',i)
            for j in tqdm(os.listdir(folderPath)):
                img = cv2.imread(os.path.join(folderPath,j))
                img = cv2.resize(img,(self.image_size[0], self.image_size[1]))
                X_train.append(img)
                y_train.append(i)
                
        X_train = np.array(X_train)
        X_train = X_train / 255.
        y_train = np.array(y_train)

        y_train_new = []
        for i in y_train:
            y_train_new.append(labels.index(i))
        y_train = y_train_new
        y_train = tf.keras.utils.to_categorical(y_train)
        return (X_train, y_train)

    def loss(self, y_true, y_pred):
        # scale predictions so that the class probas of each sample sum to 1
        y_pred /= K.sum(y_pred, axis=-1, keepdims=True)
        # clip to prevent NaN's and Inf's
        y_pred = K.clip(y_pred, K.epsilon(), 1 - K.epsilon())
        # calc
        loss = y_true * K.log(y_pred) * np.array([10, 1, 1, 1])
        loss = -K.sum(loss, -1)
        return loss

    def fit(self, learning_rate: float, epochs: int):

        effnet = EfficientNetB0(weights='imagenet',include_top=False,input_shape=(self.image_size[0],self.image_size[1],3))
        model = effnet.output
        model = tf.keras.layers.GlobalAveragePooling2D()(model)
        model = tf.keras.layers.Dropout(rate=0.5)(model)
        model = tf.keras.layers.Dense(4,activation='softmax')(model)
        model = tf.keras.models.Model(inputs=effnet.input, outputs = model)
        model.compile(loss=self.loss,optimizer = 'Adam', metrics= ['accuracy'])

        history = model.fit(self.X_train,self.y_train,validation_split=0.1, epochs = epochs, batch_size=self.batch_size)

        return model

image_size = (150, 150)
batch_size = 32
asylnn = AssymetricLossNeuralNetwork(k = (10.0, 1.0, 1.0, 1.0), image_size = image_size, batch_size = batch_size)
model = asylnn.fit(0.001, 10)

X_test = []
y_test = []

for i in labels:
    folderPath = os.path.join('/content/data','Testing',i)
    for j in tqdm(os.listdir(folderPath)):
        img = cv2.imread(os.path.join(folderPath,j))
        img = cv2.resize(img,(image_size,image_size))
        X_test.append(img)
        y_test.append(i)
        
X_test = np.array(X_train)
y_test = np.array(y_train)

y_test_new = []
for i in y_test:
    y_test_new.append(labels.index(i))
y_test = y_test_new
y_test = tf.keras.utils.to_categorical(y_test)

from sklearn.metrics import classification_report, confusion_matrix

pred = model.predict(X_test)
pred = np.argmax(pred,axis=1)
y_test_new = np.argmax(y_test,axis=1)

print(classification_report(y_test_new,pred))